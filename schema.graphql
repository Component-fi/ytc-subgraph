type Registry @entity {
  "The registry is an all purpose object to provide a list of all entities of a certain type during indexing"
  id: ID!
  terms: [Term!]!
  "Used for periodic updates that use terms as reference"
  lastUpdateTerms: BigInt!
  yieldPools: [YieldPool!]!
  "Used for periodic updates that use yield pools as reference"
  lastUpdateYieldPools: BigInt!
  principalPools: [PrincipalPool!]!
  "Used for periodic updates that use principal pools as reference"
  lastUpdatePrincipalPools: BigInt!
  baseTokens: [BaseToken!]!
  "Used for periodic updates that use baseTokens as reference"
  lastUpdateBaseTokens: BigInt!
  principalTokens: [PrincipalToken!]!
  "Used for periodic updates that use principalTokens as reference"
  lastUpdatePrincipalTokens: BigInt!
  yieldTokens: [YieldToken!]!
  "Used for periodic updates that use yieldTokens as reference"
  lastUpdateYieldTokens: BigInt!
  priceFeeds: [PriceFeed!]!
  "Used for periodic updates that use priceFeeds as reference"
  lastUpdatePriceFeeds: BigInt!
}

type Term @entity {
  id: ID!
  address: Bytes!
  expiration: BigInt!
  timeStarted: BigInt!
  baseToken: BaseToken!
  entryTransactions: [EntryTransaction!]! @derivedFrom(field: "term")
  trancheDecimals: Int!
  wrappedDecimals: Int!
  yToken: YieldToken! @derivedFrom(field: "term")
  pToken: PrincipalToken! @derivedFrom(field: "term")
}

type AccruedValue @entity {
  "Values representing accrued interest backing a yield token"
  id: ID!
  trancheSupply: BigInt!
  ytSupply: BigInt!
  wrappedSupply: BigInt!
}

type YieldPoolState @entity {
  "A snapshot of the state of a yield pool"
  id: ID!
  "Timestamp object used for finding multiple states at one timestamp"
  timestamp: Timestamp!
  "Timestamp int used for sorting"
  timestampId: BigInt!
  ytReserves: BigInt!
  baseReserves: BigInt!
  spotPrice: BigDecimal!
  pool: YieldPool!
  accruedValue: AccruedValue!
}

type PrincipalPoolState @entity {
  id: ID!
  "Timestamp object used for finding multiple states at one timestamp"
  timestamp: Timestamp!
  "Timestamp int used for sorting"
  timestampId: BigInt!
  ptReserves: BigInt!
  baseReserves: BigInt!
  totalSupply: BigInt!
  spotPrice: BigDecimal!
  fixedRate: BigDecimal!
  pool: PrincipalPool!
}

type EntryTransaction @entity {
  "A yield token compounding transaction"
  id: ID!
  numberOfCompounds: Int!
  term: Term!
  amountCollateralDeposited: BigInt!
  baseTokensSpent: BigInt!
  yieldTokensReceived: BigInt!
  gasPrice: BigInt!
  "This unfortunately is the gas limit not actual gas used, as that is not yet supported by the Graph"
  gasLimit: BigInt!
  from: User!
  "Timestamp object used for finding multiple states at one timestamp"
  timestamp: Timestamp!
  "Timestamp int used for sorting"
  timestampId: BigInt!
  accruedValue: AccruedValue!
}

type BaseToken @entity {
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
  terms: [Term!]! @derivedFrom(field: "baseToken")
  yPools: [YieldPool!]! @derivedFrom(field: "baseToken")
  pPools: [PrincipalPool!]! @derivedFrom(field: "baseToken")
}

type YieldToken @entity {
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
  term: Term!
  pool: YieldPool @derivedFrom(field: "yToken")
}

type PrincipalToken @entity {
  id: ID!
  expiration: BigInt!
  name: String!
  symbol: String!
  decimals: Int!
  term: Term!
  pool: PrincipalPool @derivedFrom(field: "pToken")
}

type User @entity {
  id: ID!
  Transactions: [EntryTransaction!]! @derivedFrom(field: "from")
  YieldLiquidityChangeEvents: [YieldLiquidityChangeEvent!]! @derivedFrom(field: "liquidityProvider")
  PrincipalLiquidityChangeEvents: [PrincipalLiquidityChangeEvent!]! @derivedFrom(field: "liquidityProvider")
}

type YieldPool @entity {
  id: ID!
  yToken: YieldToken!
  baseToken: BaseToken!
  yTokenWeight: BigInt!
  baseTokenWeight: BigInt!
  address: Bytes!
  swapFeePercentage: BigInt!
  name: String!
  term: Term!
  states: [YieldPoolState!]! @derivedFrom(field: "pool")
}

type PrincipalPool @entity {
  id: ID!
  pToken: PrincipalToken!
  baseToken: BaseToken!
  unitSeconds: BigInt!
  swapFeePercentage: BigInt!
  address: Bytes!
  states: [PrincipalPoolState!]! @derivedFrom(field: "pool")
}

type Timestamp @entity {
  id: ID!
  principalPoolStates: [PrincipalPoolState!]! @derivedFrom(field: "timestamp")
  yieldPoolStates: [YieldPoolState!]! @derivedFrom(field: "timestamp")
  entryTransactions: [EntryTransaction!]! @derivedFrom(field: "timestamp")
  prices: [Price!]! @derivedFrom(field: "timestamp")
  "The day entity allows for grouping timestamps by day in a query"
  day: Day!
  hour: Hour!
}

type PriceFeed @entity {
  id: ID!
  numeratorName: String!
  denominatorName: String!
  "The base token address, quote address is USD"
  tokenAddress: Bytes!
  prices: [Price!]! @derivedFrom(field: "priceFeed")
}

type Price @entity {
  id: ID!
  priceFeed: PriceFeed!
  price: BigInt
  decimals: Int
  "Timestamp object used for finding multiple states at one timestamp"
  timestamp: Timestamp!
  "Timestamp int used for sorting"
  timestampId: BigInt!
}

type Day @entity {
  "Day entity allows for grouping timestamps within a UTC day"
  id: ID!
  "Int value of the year"
  yearInt: Int!
  "Int value of the month 1-12"
  monthInt: Int!
  "Int value of the day 1-31"
  dayInt: Int!
  hours: [Hour!]! @derivedFrom(field: "day")
  "The first timestamp in the day entity, this is used for sorting as we can't do nested sorts"
  firstTimestamp: BigInt!
  timestamps: [Timestamp!]! @derivedFrom(field: "day")
}

type Hour @entity {
  "Hour entity allows for grouping timestamps within a UTC hour"
  id: ID!
  "Int value of the year"
  yearInt: Int!
  "Int value of the month 1-12"
  monthInt: Int!
  "Int value of the day 1-31"
  dayInt: Int!
  "Day enitty"
  day: Day!
  "Int value of the hour 1-24"
  hourInt: Int!
  "The first timestamp in the hour entity, this is used for sorting as we can't do nested sorts"
  firstTimestamp: BigInt!
  timestamps: [Timestamp!]! @derivedFrom(field: "hour")
}

type SwapTransaction @entity {
  id: ID!
  timestamp: Timestamp!
  timestampId: BigInt!
  amountIn: BigInt!
  amountOut: BigInt!
  tokenInAddress: Bytes!
  tokenOutAddress: Bytes!
  yieldPool: YieldPool
  principalPool: PrincipalPool
}

type PrincipalLiquidityChangeEvent @entity {
  id: ID!
  timestamp: Timestamp!
  tokens: [String!]!
  deltas: [BigInt!]!
  liquidityProvider: User!
  liquidityPosition: PrincipalLiquidityPosition!
  pool: PrincipalPool!
}

type YieldLiquidityChangeEvent @entity {
  id: ID!
  timestamp: Timestamp!
  tokens: [String!]!
  deltas: [BigInt!]!
  liquidityProvider: User!
  liquidityPosition: YieldLiquidityPosition!
  pool: YieldPool!
}

type PrincipalLiquidityPosition @entity {
  id: ID!
  liquidityProvider: User!
  pool: PrincipalPool!
  principalLiquidityChangeEvents: [PrincipalLiquidityChangeEvent!]! @derivedFrom(field: "liquidityPosition")
}

type YieldLiquidityPosition @entity {
  id: ID!
  liquidityProvider: User!
  pool: YieldPool!
  yieldLiquidityChangeEvents: [YieldLiquidityChangeEvent!]! @derivedFrom(field: "liquidityPosition")
}

type PrincipalSwapTransaction @entity {
  id: ID!
}